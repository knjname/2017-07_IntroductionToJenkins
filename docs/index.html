<!DOCTYPE html>
<html>
  <head>
    <title>2017/07 Jenkins 導入会</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source" style="visibility: hidden">
class: center, middle

# 2017/07 Jenkins 導入会

by Kenji Saitou

---

# 今日話す内容

Jenkinsについてテーマにする予定でしたが、僕の実際の開発体験談をベースにJenkinsのイントロをやっていきます。

---

# 今日ターゲットにする人

* Jenkinsやったことない人、さわったことない人
* リリース作業に失敗している人
* 大規模PJで開発効率をあげたい人

---

class: center, middle

# Motivation

我々は何に困っているのか？

![motivation](motivation.png)

---

## 我々は何に困っているのか？

* ビルド・リリースの属人化
  * 😅「Aさんのマシンじゃないとビルドできないよ…」
  * 😅「ビルド・リリース手順が複雑すぎて死ぬ」
  * 😅「今本番に入っているアプリって、どのバージョンだっけ？」

👻 ビルド用の秘伝のタレマシン、リリースに再現性が無い、もしかしたら知らない変更が入っているかもしれない…

リリース手順を今覚えていても、期間があけばすぐ忘れてしまうもの。人生がプロジェクトに拘束される。

---

## 我々は何に困っているのか？

* コンパイル・単体テストがいつの間にか通らなくなっている
  * 😢「なんかビルド通らない」
  * 😢「コンパイルエラーがそこらかしこで出ている」
  * 😢「何が原因か分からない。いつからこうなった…」  
  * 😢（割れ窓の誕生）

👻 プロジェクトはまるで無法地帯。大規模だと大変苦労するケース。

---

## 我々は何に困っているのか？

* 自動化の欠如：毎日の作業を手でやっている（ルーチンワーク）
  * 🐙「今日あれやった？」
  * 😿「明日は休みたいです…」

👻 人生がプロジェクトに拘束される。

---

class: center, middle

# Jenkinsとは何か？

![:scale 50%](docker.png)

---

## 簡単にいえば、cron＋Web画面

* 簡単にいえば、Web画面の付いたcron
  * 決まったタイミングで、決まった行動をする
  * 行動の結果やログ、成果物は、JenkinsのWeb画面で見られる
  * 世間ではCI（Continuous Integration）ツールとして扱われているが、別にジョブスケジューラーとして活用してもよい。
  * もちろん、この言葉では尽くせないぐらいの便利機能がたくさんある。
* [https://ci.jenkins.io/ - 設置例](https://ci.jenkins.io/)

---

## アーキテクチャ

* Java7 移行で動作。
* データベースは不要。設定はほとんどすべて`${JENIKNS_HOME}`以下にXMLファイルで保存します。
* プラグインアーキテクチャ
* マスター・スレーブ構成。
* Javaベースとはいえ、Jenkinsでよく使われている言語はGroovy。

---

## インストール

* [設置](https://jenkins.io/download/)
  * Javaなので、Linux・Windows問わず。
    * ただし、Windowsはファイルロックなどの仕様があるので、利用はおすすめしません。
    * Windows製品に依存するビルドをするからといって、Windowsに設置する必要は一切ありません。
    * 基本的にコンパイルターゲットとなるOSとJenkinsを設置するOSは別々で考えてOK。Javaの動作は必要。
  * JavaEEアプリとして、`*.war`になっているのでTomcatでデプロイすることも可能
  * 最近の流行りは [🐳 Docker 🐳](http://knjname.hateblo.jp/entry/2015/02/10/040833)
  * Linuxならパッケージマネージャ経由で入ります。イチバン楽なのはこれ。
* バージョンは、LTS(長期サポート版) 使っておきましょう。
* 個人的にはJenkins本体のマシンはIO性能が高いマシンがいいと思います。

---

## ジョブ

* 基本構成単位
* 構成要素
  * いつ（トリガー：指定日時になったら、ソースが更新されたら、ボタンが押されたら、など）
  * どこからソースをチェックアウトして （Git, Subversion）
  * どんなビルドをして (コマンドの実行)
  * どういう結果を残すのか（後続のジョブを起動するとか）
  * 基本的にはコマンドで実行できるなら、なんでもできる
* フォルダわけ可能
* [プログラミングで生成可能。](http://qiita.com/mas0061/items/7288ba09ed7d99e46b54)

---

## ビルド

* 1ビルド＝ジョブが1回動いた結果
* 構成要素
  * 何をチェックアウトしたか
    * Gitならコミットハッシュ、Subversionならリビジョン番号
  * ビルドログ
    * コンパイル中のログなど
  * ビルドアーティファクト
    * ビルド結果としての成果物
      * JavaならJARファイルとか

---

## マスターノード・スレーブノード

* 初心者は軽視しがちだが、Jenkinsの大事な機能
* Jenkinsは複数台で実行できる
* マスターノード
  * マスターノード: 1台のみ。Jenkins本体が動く。Web画面の提供、設定の保存、ビルド（ログなど）の保存
  * スレーブノード: 0〜N台で構成。マスターからの指示をうけてビルドを実行。
* マスターノードが司令塔となり、スレーブノードにビルド指示を出してジョブを実行
* [マスターノードでビルドをさせることもできますが、おすすめしません](http://knjname.hateblo.jp/entry/2014/05/03/190842)

---

## マスターノード・スレーブノード

* Windowsアプリのビルドをしたい
  * Windowsマシンで構成したスレーブノードでビルドしましょう
* XCodeでビルドをしたい
  * macOSマシンで構成したスレーブノードでビルドしましょう
* ビルド内容として、特定マシンからしかつながらないネットワークとやりとりする必要がある
  * その特定マシンをスレーブノードにしましょう

---

## スレーブノードの接続形態いろいろ

* 基本的にスレーブノードはマスターノードと通信するエージェントを持って起動する
* SSH
  * マスターノードからスレーブノードにしたいマシンにSSHでつないでエージェントを起動
  　* 接続先にJavaのインストールが必要
* [JNLP](https://ja.wikipedia.org/wiki/Java_Web_Start)
  * スレーブノードからマスターノードにJNLPプロトコルを使って接続しにいく
  * クラウド上のJenkinsにファイアウォール経由でつなぎに行く時などに便利
  * どちらかというとSSHよりこちらのほうがおすすめ
  * [SwarmPlugin](https://wiki.jenkins.io/display/JENKINS/Swarm+Plugin) を付けば、アドホックにスレーブを起動して、動的にJenkinsに追加していける
* 最近はスレーブはDockerで構成するのが流行っている

---

## プラグイン

* Jenkinsはプラグインで機能を追加して利用するのが普通
* 素のままは何もできません
* 最近のJenkinsはおすすめプラグインをインストール時に勝手にリコメンドしてくれます
* 更新がとまってるプラグイン、あげると互換性をなくすやつもいる…
  * 安定が大事なJenkinsだとプラグインのアップグレードもある程度試験環境で検証したほうがいいです

---

## ログイン・権限・認可

* 内部認証可能
* LDAP連携可能
  * フォルダごとにLDAPグループで操作可否付与など細かく設定可能
* OAuthもあったはず

---

## REST API

* [Jenkins自体がREST APIを持っているので、REST API経由で操作・情報取得が可能。](http://knjname.hateblo.jp/entry/2014/11/12/220104)


---

class: center, middle

# 私の体験談

![:scale 50%](docker.png)

---

## それは某巨大Javaプロジェクトで始まった…

* 今国内で稼働しているシステムを海外向けに移植したい
  * フレームワークの改修を行いたい。
  * ついでに業務も移行したい。今まであった業務消えたりします。
      * 大量の設計書も変更対象…！
  * コード体系かわります。テーブル減ります。 etc
  * 業務部分の開発は海外にオフショアします。
      * 言語の壁！ （互いにノンネイティブ同士の英会話！）
      * 価値観の壁！　（忖度なんて期待できない！明確なものが必要！）
      * 距離の壁！　（遠い海外、いちいちエラーでミーティング開きますか？）

---

## そのまま徒手空拳やってたら死亡するフラグ

* 大規模だもの、みんな平気でやらかします
  * ビルドが通らないコードをコミットする
    * そして気づかない
    * 「僕は悪くない」
  * 大人数の誰一人も失敗しない場合にだけ動く仕組みなんか運用できないよねー
* なんとかしないとね！
  * → そうだ CI しよう！

…というようなストーリーが明確にあったわけではないですが、なんとなく改変に向けて危機感を感じたのでプロジェクトで提案して始めることにしました。

あなたなら、どういう手を打ちますか？またマネージメントですか？

---

## 気合いのマネジメント（）による対処は悪手

* マネジメントという名の「気合いで解決」　どう思いますか？
* 全ては仕組みの問題である
  * 人はミスをする
    * そしてミスを誘発する仕組みがある
    * ミスを問題視せざるをえない仕組みがある
    * 個人の注意力に依存する仕組みがある
  * ミスにすぐ気づけるとしたら？
  * ミスが問題にならないとしたら？

注意力という個人の資質に頼るのはやめましょう。

---

## だから、CI、はじめました

* とりあえず適当なマシンを調達してJenkinsをインストールした
  * まあ、まだ価値を理解していないところでは、予算はつかないですね…

さて、どこから始めるか？

---

## まずはコンパイルチェックから

* とりあえずプロジェクトのコンパイルが通るかだけをチェック
  * ビルドロジックがコマンドラインで自動実行できる必要がある
* 数分ごと、リポジトリにコミットがあったら、Java+Antでコンパイル。
  * 全自動でAntでコンパイルできるようにスクリプトを書いた。
    * IDEでコンパイル通るだけとか、問題外…。コマンドラインで自動化できるかがJenkinsでのビルドの鍵です。
* 単体テストをやるのは難しいが、コンパイルチェックだけならなんとかなる。
  * CI導入のはじめとしてはおすすめの課題。
* スクリプト言語だから無理？
  * スクリプト言語でもある程度の文法チェッカは備えていることは多いです。
    ```console
    $ bash -n target.sh
    ```
* コンパイルエラーは0件にするように注意。みんな自主的にJenkinsをチェックする流れ。

---

## → 効果

* ひとまずはソースを安心してみんなで改変できるようになった。
* よくある、結合試験期間が来るまで闇鍋状態を回避できた。
  * やっぱり悪の芽ははやめに詰むのに限ります。
  * 「俺のマシンでは問題ない」 ← これは防げた
* 極端な話、開発初期からリリース・デプロイまで

---

## ソースコード静的解析もやった

* 静的解析ツールをビルドで使い始めた
  * 潜在的なコードの問題を発見したりするやつ
  * [Findbugs](http://findbugs.sourceforge.net/)
  * [Checkstyle](http://checkstyle.sourceforge.net/)
  * ステップ数解析 とかも
  * [SonarQube](https://www.sonarqube.org/) とかありますね
* これも比較的簡単なのでおすすめ
* 目標：やばいエラーは0件、軽微なものはできればFix、無理なら応相談

---

## → 効果

* 問題・既存バグがあらわになる
  * 問題が実際出るか観察して対処
* コーディング規約を守らせることができる
* オフショア人材についても、機械が出すエラーに対する対処という面で、守っているか守っていないかはっきりしているので、価値観の違う相手でも通用しやすい指標となった
  * （ただし、裏でブリッジ役が教育しまくってます）

---

## もっともっと静的解析

* 僕一人が大量の成果物をチェックするプログラム書いて、事前にプロジェクト全体のエラーが分かったらすごくお得じゃない？
  * 実際に人の手で調べていたが、機械化可能なチェックをJenkins上でチェックする
  * 過去にやらかした問題について、機械でチェック可能ならJenkins上でチェックする
    * 過去の問題が二度と発生しないことを保証できる
  * 同時に成果物についてのレポートとかも出しちゃう
    * 画面遷移図 など

---

## カスタムのソースコードチェッカを作ったりしました

* プロジェクトの規約に沿った成果物が出来上がっているかチェック
* 海外向けなので日本語が残ってないかチェック
* 特定のコード体系に基づく文字列が仕様書に存在するかチェック
  * 大規模故、メッセージコードとか規約が大量にあります。これを人がチェックする？バカバカしいでしょう。
  ```java
  // Check if `MSG0001` exists in our specifications.
  String message = MessageUtils.formatMessage("MSG0001", "This cannot be done.");
  ```
* XML設定ファイルなどの整合性チェック
  * 定義が見つからないものを指していないか？2重に定義していないかなど…
  * XPathが死ぬほど役に立つ。単純に技術力でできるチェックの幅は変わってくる。
* いろんなものが機械的にチェックできる規約になっていると楽

---

## → 効果

* 大規模故、チェッカの作成工数以上の効果が得られた
* ボロボロ出てくる大量のバグ候補たち
  * お決まりのように、既存のソースからも出てるじゃん！どんだけ〜
* しかし、こういうものも
  * 偽陽性 (false positive): エラーじゃないのにエラーになるもの
    * ホワイトリストなどを作成して除外
  * 偽陰性 (false negative): エラーなのにエラーになっていないもの
    * チェック内容の見直し
* 人の手でチェックしているぐらいなら、機械化して毎日流そう。

---

## ドキュメント生成もやりました

* JavaならJavadocとか
* 一日に一度程度生成。
  * CIをまわしていると、計算機のリソースがだんだん足りなくなってくるのですが、一日に一度程度のタスクならいくら増やしてもそこまで負担にはならない。

---

## リリース・デプロイの自動化

* 最初からやりたかったことの一つ。
* リリースフローを定義し、これに従ってリリースしてもらう
* 基本的な発想は
  * 人間が介在しなくてもリリースできるようにしよう
  * SI案件のリリースフローは、だいたいステートマシンであり、承認フローを回して資材を出し入れ＋ビルド＋デプロイ＋通知するだけなのだから、機械化可能なのでは？

---

## 具体的なリリース・デプロイの流れ

* リリース申請をRedmineのチケットで実施
* 承認済みリリース申請のチケットをJenkinsが取り込んで、ソースのマージを実施 （作りこみ）
* マージしたソースからリリース資材作成
* 結合環境リリースであれば、そのまま直接リリース
  * 🌛 日中にマージ、深夜に自動リリース、翌朝テスト可能（たまに例外で緊急リリース）
    * スケジュールが決まっていると、それに応じて人が動ける！
  * 本番環境リリースであれば、リリース可能な資材の作成まで実施
* [Jenkinsではビルドパイプラインという仕組み](http://knjname.hateblo.jp/entry/2014/05/06/202603)を使うことにした

--- 

## → 効果

* いちいち面倒なリリース手順を踏まないのでリリースがまったく苦痛じゃなくなりました。
  * そもそも手を動かす必要がほとんどなくなった。
  * リリースフローが途中で落ちた時は、原因を調べて当人にRedmineでチケット投げ
* 今までいた、リブ管、リリース担当者というロールが不要になりました。
* リリース申請間で何が変更されたのか誰でも分かるようになりました。

---

## Excelの仕様書チェック

* 個人的にJenkinsの過剰利用だとは思うが、かなり心血を注いでやった
* 具体的には、大量のExcel仕様書・項目書を…
  * VBAをJenkinsで動かしてチェック
    * JenkinsからPowerShell、PowerShellからExcelマクロを起動する仕組み
      * はっきりいって不安定な上、糞面倒な仕組み
* Officeは自動化には向いていない… しかしExcel VBAぐらいしか自動化ツールが普及していない
* そもそもVBAにしたって書く人が気をつけないとフル自動化はできない
* 実際はWindowsのVMをKVMで立ち上げ、VBAを動かすインスタンスとして運用

---

## → 効果

* たしかに、そこに需要がありました。
* 設計書の単純ミスの早期防止。
* エラー件数の見える化
  * 今まで人がチェッカツールなどを動かしていたが、どれだけのエラーをFixできていたか全体把握が無理だった。
* Jenkinsに掲示されることでエラーのFix状況が把握できるようになった。

---

## ユニットテスト自動化

* これもやりたかったが、ハードルがあった
* プロジェクトの規約上、個々人で単体テスト実施をやってはいたが… 実際にこれをJenkinsで行うとなると…
  * 外部とのやり取りがないコードはテストが超簡単
  ```java
  public static int add(int x, int y) { return x + y; }
  ```
  * 外部とのやり取りがあるコードはテストが難しい、そもそもテストのことを考えていないコードが大量。
  ```java
  // 手でDBやファイルを編集しないと動かない。
  databaseQuery("SELECT * FROM foobar WHERE x = ?", foobar.getId());
  ```
* ポータブルにテストする仕組みを作成して、実施。
  * テストの前にDBを初期化させたり、強力なモック化の手段([JMockit](http://jmockit.org/))を用意したりなど…
* Jenkins上ではポータブルに構築されたテストを実施。
  * テストの成否、カバレッジ率を取得。
  * ローカルマシンに依存するテストを作るな、とガイドラインを作ったりしました。

---

## → 効果

* 回帰試験の自動化
  * きちんとJUnitできてますよね？を自動化
  * 単純にプロジェクトに安心感を持てるようになった
  * フレームワークの変更で業務が落ちるかどうか把握可能になった。
* プロジェクト大きすぎて、テストに時間がかかりまくる
  * なるべくテスト実施の単位を分ける
    * → アプリごとバラバラに実施して、実施結果はマージして取り扱う

---

## 開発環境について見るべき情報が多すぎる問題

* 割りとよくある
* Jenkinsにいろいろエラーを収集させているが、グラフが多すぎて毎日見るのが面倒
* 収集用のダッシュボードSPAアプリを作成 (AngularJS)
  * 開発サーバのトップページポータルになるようなものを作成
  * WebAPIでエラーを集計して、ひと目でいろんなエラーがわかるように
  * いろんな開発用サービスへのリンクを用意
  * 自分にアサインされている or 放置されているRedmineのチケットがわかるように

---

## ほか

* 本当に1から100まで全部Jenkinsでやった
  * DBのバックアップ取得、リポジトリの掃除（放置されたロックなど）
  * UI描画テストの自動化、開発サーバのユーザアカウント追加の自動化
  * 面白そうならJenkinsでジョブ追加
  * 開発環境での自動化は全部Jenkinsという名のWeb画面付きcronに投げる
    * みんなが見られる
  * 最終的なジョブ数は800近くぐらい（一人で管理するんですよ）
* ここまで使い倒した人間はほぼ地球上にいないと思う
  * もはやJenkinsは飲み物

---

## っていうか

* いろんな開発を効率化するために最終的に自分で開発インフラの殆どを引き取った
  * バージョン管理システム
  * チャット
  * ビルド方式
    * システム全体でJenkinsを使って自動デプロイするように誘導していった

---

## ん、これって？

* 新たな属人化が発生してない？
  * 👿ネ申👿 の誕生
  * でも楽になってはいるし、ミスもおきていない、バグも早期に発見できている、定時で帰れる…
* 一応僕がいなくとも、回ってはいる模様
  * まあでも僕がいなくなったら嫌なことになりますね
* 開発インフラはみんなで保守していくチーム体制が大事　**みんな興味持って！**

---

## 他のプロジェクトへ構築ヘルプに行くの巻

こういう取り組みを通じて非常に効果をあげたことで、そこらへんに評判が広がり、他プロジェクトにJenkinsなどを設置しにいくこと数度。

* 残念なが全般的にうまくいかなかった
  * 抵抗される、無視される、放置される
* ツールは設置できるが、カルチャーを設置するのはとっても難しい
  * いろんな人が理解して、布教して、便利さや考え方を理解してもらう必要がある
  * 一人だけが頑張っても無駄
* 継続してプロジェクトにフィットさせる人材が必要
  * 開発インフラ構築だけ切り離す、なんてのは夢の夢
* 開発インフラの価値が理解されないこともある
  * 手でビルドリリース、共有フォルダで管理を当然だと思っている人たちが大勢いる
  * 私達で主導権を握って開発インフラを構築する主体性をうまくできないと全員で詰む

---

## CIを導入することへの提言

* やれば効果が確実にあがるという意味では、CIは本当に導入が楽な施策ですよ。
  * やって効果があるかわからないことはいっぱいある
  * CIはやれば効果が出る
* 便利な仕組みを知った開発者が他所にいって、その便利な仕組みを広めていけば、いいと思った
  * 一度便利な仕組みになれると以前の不便には耐えられなくなる

---

## CIを導入することへの提言

* 自動でビルドをまわすのは義務
* プロジェクト初期でリリースまでつないでおけ
  * 💩 結合あたりで遅延こいて便秘するプロジェクトはたくさんある 💩
  * スルーっとビルドパイプラインを通しましょう。どんどんデプロイできるようにしておきましょう。
  * 実製品が動いていることほど説得力があるものはない。
  * デリバリーまで繋がっていれば、末端業務が死んでもだいたい問題ない（暴言）

---

class: center, middle

# Jenkinsをはじめる

![:scale 50%](docker.png)

---

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>

    remark.macros.scale = function (percentage) {
        var url = this;
        return '<img src="' + url + '" style="width: ' + percentage + '" />';
    };

      var slideshow = remark.create();
    </script>
  </body>
</html>